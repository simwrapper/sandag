import{H as v,g as k}from"./index-D5-tbn2z.js";import{f as L}from"./util-CHADgdP7.js";import{a as P}from"./avro-Dd9UqmeZ.js";import{W as R}from"./RoadNetworkLoader.worker-Bt7-RMFX.js";import{C as b}from"./Coords-CQQjH_Bj.js";import{r as S}from"./group-DobYzF2-.js";function F(w){return new Worker("/assets/DataFetcher.worker-C5P2VYqm.js",{name:w?.name})}const C=!!window.showDirectoryPicker,D=!C;class T{constructor(...t){this.root=t.length?t[0]:"",this.subfolder=t.length?t[1]:"",this.fileApi=this._getFileSystem(this.root)}threads=[];subfolder="";root="";fileApi;networks={};featureCollections={};kill(){for(const t of this.threads)t.terminate()}getFilteredDataset(t){return t.dataset in this.datasets?{filteredRows:this.datasets[t.dataset].filteredRows}:{filteredRows:null}}async OLDgetFiltered(t){const s=this.datasets[t.dataset].filteredRows;if(!s)return{filteredRows:null};let e={};if(t.value&&t.groupBy){const i=t.value,n=t.groupBy;e=S(s,d=>d.reduce((a,r)=>a+r[i],0),d=>d[n])}const c=Array.from(e.keys()),o=Array.from(e.values());return{filteredRows:{x:c,y:o}}}async getDataset(t,s){try{const e=`${s?.subfolder||this.subfolder}/${t.dataset}`;this.datasets[e]||(console.log("LOAD:",e),this.datasets[e]={dataset:this._fetchDataset(t,s),activeFilters:{},filteredRows:null,filterListeners:new Set});let o=await((a,r)=>{const u=new Promise((l,h)=>{setTimeout(()=>{h(new Error(`Operation timed out after ${r}s`))},r*1e3)});return Promise.race([a,u])})(this.datasets[e].dataset,60),{_comments:i,...n}=o,d=i;return t.ignoreColumns&&t.ignoreColumns.forEach(a=>{delete n[a]}),t.useLastRow&&Object.keys(n).forEach(a=>{const r=o[a].values;n[a]=r[r.length-1]}),{allRows:n,comments:d}}catch(e){const c=(""+e).replaceAll("Error: ","");throw console.error(c),Error(c)}}setRowWisePropertyTable(t,s,e){const c=t.substring(t.lastIndexOf("/")+1);let o={dataset:c};return typeof e!="string"&&(o=Object.assign(o,e)),this.datasets[c]={activeFilters:{},filteredRows:null,filterListeners:new Set,dataset:new Promise(i=>{i(s)})},this.datasets[c].dataset}getFeatureCollection(t){return this.featureCollections[t]}async registerFeatures(t,s,e){this.featureCollections[t]=s;const c=s.map(o=>o.properties||{});await this.setFeatureProperties(t,c,e),s.forEach(o=>{o.properties={}})}setFeatureProperties(t,s,e){const c=t.substring(t.lastIndexOf("/")+1),o=`${e?.subfolder||""}/${c}`;let i={dataset:o};return typeof e!="string"&&(i=Object.assign(i,e)),this.datasets[o]={activeFilters:{},filteredRows:null,filterListeners:new Set,dataset:new Promise((n,d)=>{const a=new F;this.threads.push(a);try{a.postMessage({config:i,featureProperties:s}),a.onmessage=r=>{a.terminate(),r.data.error&&(console.error(r.data.error),d(`Problem loading properties in ${t}`)),n(r.data)}}catch(r){a.terminate(),console.error(r),d(r)}})},this.datasets[o].dataset}setPreloadedDataset(t){this.datasets[t.key]={dataset:new Promise((s,e)=>{s(t.dataTable)}),activeFilters:{},filteredRows:null,filterListeners:new Set}}async getRoadNetwork(t,s,e,c){const o=`/${s}/${t}`,i={};return e.projection&&(i.crs=e.projection),this.networks[o]||(this.networks[o]=this._fetchNetwork({subfolder:s,filename:t,vizDetails:e,cbStatus:c,options:i})),await this.networks[o]}async setFilter(t){const{dataset:s,column:e,value:c,invert:o,range:i}=t;if(!this.datasets[s]){console.warn(`${s} doesn't exist yet`),console.warn(Object.keys(this.datasets));return}console.log("> setFilter",s,e,c);const n=Array.isArray(c)?c:[c];this.datasets[s].activeFilters==null&&(this.datasets[s].activeFilters={});const d=this.datasets[s].activeFilters;n.length?d[e]={values:n,invert:o,range:i}:delete d[e],await this._updateFilters(s)}addFilterListener(t,s){try{const e=`${t.subfolder||this.subfolder}/${t.dataset}`;if(!this.datasets[e])throw Error("Can't add listener, no dataset named: "+e);this.datasets[e].filterListeners.add(s)}catch(e){console.error("CANT ADD FILTER LISTENER"+e)}}removeFilterListener(t,s){const e=`${t.subfolder||this.subfolder}/${t.dataset}`;try{this.datasets[e].filterListeners&&this.datasets[e].filterListeners.delete(s)}catch{}}clearCache(){this.kill(),this.datasets={},this.networks={}}async _updateFilters(t){console.log("> updateFilters ",t);const s=this.datasets[t];if(console.log({metaData:s}),!Object.keys(s.activeFilters).length){console.log("no keys"),s.filteredRows=null,this._notifyListeners(t);return}const e=await s.dataset,c=Object.keys(e);let o=[];const i=e[c[0]].values.length;console.log("FILTERS:",s.activeFilters),console.log("TOTLROWS",i);const n=new Array(i).fill(!0),d=/^(<|>)/;for(const[a,r]of Object.entries(s.activeFilters)){const u=e[a];if(r.values[0]===void 0||r.values[0]==="")throw Error(t+": filter error");if(d.test(r.values[0]))r.values[0].startsWith("<=")?(r.conditional="<=",r.values[0]=r.values[0].substring(2).trim()):r.values[0].startsWith(">=")?(r.conditional=">=",r.values[0]=r.values[0].substring(2).trim()):r.values[0].startsWith("<")?(r.conditional="<",r.values[0]=r.values[0].substring(1).trim()):r.values[0].startsWith(">")&&(r.conditional=">",r.values[0]=r.values[0].substring(1).trim());else if(r.values.length===1&&typeof r.values[0]=="string"){const l=parseFloat(r.values[0]);Number.isFinite(l)&&r.values.push(l)}for(let l=0;l<i;l++)E(r,u.values[l])||(n[l]=!1)}for(let a=0;a<i;a++)if(n[a]){const r={};c.forEach(u=>r[u]=e[u].values[a]),o.push(r)}s.filteredRows=o,this._notifyListeners(t)}_notifyListeners(t){const s=this.datasets[t];for(const e of s.filterListeners)e(t)}async _fetchDataset(t,s){const{files:e}=await new v(this.fileApi).getDirectory(s?.subfolder||this.subfolder);return new Promise((c,o)=>{const i=new F;this.threads.push(i);try{i.postMessage({fileSystemConfig:this.fileApi,subfolder:s?.subfolder||this.subfolder,files:e,config:t,options:s}),i.onmessage=n=>{if(i.terminate(),!n.data||n.data.error){let d=""+(n.data?.error||"Error loading file");d=d.replace("[object Response]","Error loading file"),t?.dataset&&d.indexOf(t.dataset)===-1&&(d+=`: ${t.dataset}`),o(d)}c(n.data)}}catch(n){i.terminate(),console.error(n),o(n)}})}async _getAvroNetwork(t){const e=await new v(this.fileApi).getFileBlob(`${t.subfolder}/${t.filename}`),o=(await new Promise(async(f,p)=>{const m=[];P.createBlobDecoder(e).on("metadata",y=>{}).on("data",y=>{m.push(y)}).on("end",()=>{f(m)})}))[0],i=o.linkId.length,n=o.crs||"EPSG:4326",d=n!=="EPSG:4326"&&n!=="WGS84",a=new Float32Array(2*i),r=new Float32Array(2*i),u=[];let l=[0,0],h=[0,0];for(let f=0;f<i;f++){const p=o.linkId[f],m=2*o.from[f],y=2*o.to[f];l[0]=o.nodeCoordinates[m],l[1]=o.nodeCoordinates[1+m],h[0]=o.nodeCoordinates[y],h[1]=o.nodeCoordinates[1+y],d&&(l=b.toLngLat(n,l),h=b.toLngLat(n,h)),a[2*f+0]=l[0],a[2*f+1]=l[1],r[2*f+0]=h[0],r[2*f+1]=h[1],u[f]=p}const g={source:a,dest:r,linkIds:u,projection:"EPSG:4326"};for(const f of o.linkAttributes)f!=="linkId"&&(g[f]=o[f]);return g}async _fetchNetwork(t){return new Promise(async(s,e)=>{const{subfolder:c,filename:o,vizDetails:i,cbStatus:n,options:d}=t,a=`/${c}/${o}`;console.log("load network:",a);let r=a.indexOf("/")>-1?a.substring(0,a.lastIndexOf("/")):this.subfolder;try{const{files:l}=await new v(this.fileApi).getDirectory(r);let h=a.indexOf("/")===-1?a:a.substring(a.lastIndexOf("/")+1);L(l,h).length!==1&&e("File not found: "+a)}catch{e("Error reading folder: "+r)}if(o.toLocaleLowerCase().endsWith(".avro")){const l=await this._getAvroNetwork(t);s(l);return}const u=new R;try{u.onmessage=l=>{if(l.data.promptUserForCRS){let h=prompt('Enter the projection coordinate reference system, e.g. "EPSG:25832", or cancel if unknown')||"Atlantis";Number.isInteger(parseInt(h))&&(h=`EPSG:${h}`),u.postMessage({crs:h});return}if(l.data.status){n&&n(l.data.status);return}u.terminate(),l.data.error&&(console.error(l.data.error),e(l.data.error)),s(l.data.links)},u.postMessage({filePath:a,fileSystem:this.fileApi,vizDetails:i,options:d,isFirefox:D})}catch(l){u.terminate(),console.error(l),e(l)}})}_getFileSystem(t){const s=k.state.svnProjects.filter(e=>e.slug===t);if(s.length===0)throw console.error(`DDM: no such project, is slug correct? (${t})`),Error;return s[0]}datasets={}}function E(w,t){const s={"<":()=>t<w.values[0],"<=":()=>t<=w.values[0],">":()=>t>w.values[0],">=":()=>t>=w.values[0]};let e;return w.range?e=t>=w.values[0]&&t<=w.values[1]:w.conditional?e=s[w.conditional]():e=w.values.includes(t),w.invert?!e:e}export{T as D,F as W,E as c};
